<p-slide timing="1000" autoplay="special-file">
  <p-fragment timing-start="10" class="special-file" style="top: 3em; rotate: 329deg; left: 3em"> layout.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 4em; rotate: 341deg; left: 9em"> page.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 2em; right: 3em; rotate: 36deg"> loading.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 8em; right: 5em; rotate: 36deg"> not-found.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 2em; right: 8em; rotate: 36deg"> error.tsx </p-fragment>
  <p-fragment class="special-file" style="left: 3em; rotate: 332deg; bottom: 3em"> global-error.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 10em; right: 10em; rotate: 337deg"> route.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 6em; right: 3em; rotate: 3deg"> template.tsx </p-fragment>
  <p-fragment class="special-file" style="top: 11em; right: 4em; rotate: 36deg"> default.tsx </p-fragment>
  <p-fragment no-autoplay style="z-index: 1"><img class="full-media" src="img/cry-sad.gif" alt="special-files-omg" style="height: 90%; top: 0.5em; bottom: 0.5em" /></p-fragment>
</p-slide>
<p-slide class="full-media-no-padding">
  <div class="star-wars-intro">
    <p class="intro-text">But first, a bit of history.</p>
    <!-- All Scrolling Content Goes in here -->
    <div class="main-content">
      <div class="title-content">
        <p class="content-header">NextJS<br />before server component</p>
        <br />
        <p class="content-body">
          Before the introduction of server components, NextJS primarily relied on React components, which are client-side components rendered on the browser.
          <br />
          These components are part of the client-side rendering (CSR) approach where the entire page is initially rendered on the client side.
          <br />
          By default, NextJS uses CSR, where React components are rendered on the client's browser. When a user navigates to a page, NextJS sends the necessary JavaScript bundles
          to the browser, which then executes React to render the page.
        </p>
      </div>
    </div>
  </div>
</p-slide>
<p-slide>
  <p-note class="center">
    <h4 style="margin-bottom: 0.7em">Server Components ğŸ—„ï¸</h4>
    <p class="small-text">React Server Components allow you to write UI that can be rendered and optionally cached on the server.</p>
  </p-note>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.7em">ğŸ™Œ Some Benefit ğŸ™Œ</h4>
  <ul class="long-list">
    <p-fragment
      ><li>ğŸ“Œ <span class="graphik-medium">Fetching:</span> Server Components allow you to move data fetching to the server, closer to your data source</li></p-fragment
    >
    <p-fragment
      ><li>
        ğŸ“Œ <span class="graphik-medium">Security:</span> Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk
        of exposing them to the client
      </li></p-fragment
    >
    <p-fragment
      ><li>
        ğŸ“Œ <span class="graphik-medium">Performance:</span> Server Components allow you to cache the UI on the server, reducing the amount of work the client needs to do
      </li></p-fragment
    >
    <p-fragment
      ><li>ğŸ“Œ <span class="graphik-medium">SEO:</span> Server Components allow you to render the UI on the server, improving SEO and performance</li></p-fragment
    >
    <p-fragment
      ><li>
        ğŸ“Œ <span class="graphik-medium">Initial Page Load and First Contentful Paint (FCP):</span> On the server, we can generate HTML to allow users to view the page immediately,
        without waiting for the client to download, parse and execute the JavaScript needed to render the page.
      </li></p-fragment
    >
  </ul>
  <p-notes>
    Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page
    earlier without having to wait for the entire page to be rendered on the server.
  </p-notes>
  <p-notes>
    Bundle Sizes: Server Components allow you to keep large dependencies that previously would impact the client JavaScript bundle size on the server. This is beneficial for users
    with slower internet or less powerful devices, as the client does not have to download, parse and execute any JavaScript for Server Components.
  </p-notes>
</p-slide>
<p-slide class="center">
  <p-note style="margin-bottom: 1em" class="attention"> Important </p-note>
  <p-note style="--default-more-space: 1.6em" class="small-text more-space"
    ><span class="graphik-medium">By default, NextJS uses Server Components.</span> This allows you to automatically implement server rendering with no additional configuration,
    and you can opt into using Client Components when needed.
  </p-note>
  <p-notes> To use Client Components, you must add 'use client' at the beginning of the file. </p-notes>
</p-slide>
<p-slide>
  <p-note class="center">
    <h4 style="margin-bottom: 0.7em">Client Components ğŸ™‚â€â†”ï¸</h4>
    <p class="small-text">Client Components allow to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser</p>
  </p-note>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.7em">ğŸ™Œ Some Benefit ğŸ™Œ</h4>
  <ul class="long-list">
    <p-fragment
      ><li>
        ğŸ“Œ <span class="graphik-medium">Interactivity:</span> Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user
        and update the UI
      </li></p-fragment
    >
    <p-fragment
      ><li>ğŸ“Œ <span class="graphik-medium">Browser APIs:</span> Client Components have access to browser APIs, like geolocation or localStorage</li></p-fragment
    >
  </ul>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre class="small-line" data-label-file="client-component.tsx"><p-fragment><code style="font-size: .8em" class="language-javascript">
  'use client'</code></p-fragment>

 <code style="font-size: .8em" class="language-javascript"> import { useState } from 'react'
  
  export default function Counter() {
    const [count, setCount] = useState(0);
    return (
      &lt;div>
        &lt;p>You clicked {count} times&lt;/p>
        &lt;button onClick={() => setCount(count + 1)}>Click me&lt;/button>
      &lt;/div>
    )
  }
  </code></pre>
</p-slide>
<p-slide style="--starting-point-gradient: #bbbaba" class="gradient-sub-section center">
  <h5>Now we can explore the special file</h5>
  <img src="img/letsgo.gif" alt="letsgo" class="alter-image-size" />
</p-slide>
<p-slide class="cover-subSection">
  <h1>layout.tsx</h1>
</p-slide>
<p-slide>
  <h6 style="margin-bottom: 0.6em">
    A layout is UI that is shared between multiple routes. <br />On navigation, layouts preserve state, remain interactive, and do not re-render. Layouts can also be nested.
  </h6>
  <pre data-label-file="layout.tsx"><code class="language-javascript">
    interface LayoutProps {
      children: React.ReactNode
    }
    export default function DashboardLayout({children}: LayoutProps) {
      return (
        &lt;section>
          {children}
        &lt;/section>
      )
    }</code></pre>
</p-slide>
<p-slide>
  <p-note>
    <h5 style="margin-bottom: 0.7em">The Root layout</h5>
    <p class="small-text"><span class="graphik-medium">The Root layout</span> is defined at the top level of the app directory and applies to all routes.</p>
  </p-note>
  <p-notes>
    <p>This layout is required and must contain html and body tags, allowing you to modify the initial HTML returned from the server.</p>
    <p>api SEO nextJS</p>
    <p>server component by default and cannot turn in client component</p>
  </p-notes>
  <pre class="small-line" data-label-file="layout.tsx"><code class="small-text language-javascript">
    interface RootLayoutProps {
      children: React.ReactNode
    }
    export default function RootLayout({children}: RootLayoutProps) {
      return (
        &lt;html lang="en">
          &lt;body>
            {/* Layout UI */}
            &lt;main>{children}&lt;/main>
          &lt;/body>
        &lt;/html>
      )
    }
  </code></pre>
</p-slide>
<p-slide style="--starting-point-gradient: rgb(121, 120, 120)" class="center gradient-sub-section">
  <h5>Multiple Root Layouts</h5>
</p-slide>
<p-slide>
  <p-note>
    <h5 style="margin-bottom: 0.7em">Multiple Root Layouts</h5>
    <p class="small-text">To create multiple root layouts, remove the top-level layout.tsx file, and add a layout.tsx file inside each route groups.</p>
  </p-note>
  <p-notes>
    This is useful for partitioning an application into sections that have a completely different UI or experience. The &lt;html> and &lt;body> tags need to be added to each root
    layout.
  </p-notes>
  <p-fragment class="center"><img style="margin-top: 0.5em" class="alter-image-size" alt="multiple-root-layouts" src="img/route-group-multiple-root-layouts.avif" /></p-fragment>
</p-slide>
<p-slide style="--starting-point-gradient: rgb(121, 120, 120)" class="center gradient-sub-section">
  <h5>Nesting Layouts</h5>
</p-slide>
<p-slide>
  <p-note>
    <h5 style="margin-bottom: 0.7em">Nesting Layouts</h5>
    <p class="small-text">
      You can nest layouts to create a hierarchy of shared UI. When a route changes, the layout hierarchy is preserved, and only the necessary layouts are re-rendered.
    </p>
  </p-note>
  <p-fragment class="center"><img style="margin-top: 0.5em" class="alter-image-size" alt="nesting-layouts" src="img/nested-layouts-ui.avif" /></p-fragment>
</p-slide>
<p-slide style="--starting-point-gradient: rgb(188 188 188)" class="center gradient-sub-section">
  <h5>Layout: functions hooks</h5>
</p-slide>
<p-slide class="center">
  <p-note>By default, layouts <u>do not have access</u> to the current segment, due to their nature as server components</p-note>
  <p-fragment style="margin-top: 0.5em">(â•¥ï¹â•¥)</p-fragment>
</p-slide>
<p-slide timing-fragment="450" class="center" autoplay="layout-hooks">
  <p-note style="margin-bottom: 1em">NextJS comes with two hooks for retrieving information</p-note>
  <p-note style="font-size: 0.8em" class="two-columns graphik-medium">
    <p-fragment>useSelectedLayoutSegment</p-fragment>
    <p-fragment>useSelectedLayoutSegment<b>s</b></p-fragment>
  </p-note>
  <p-fragment style="margin-top: 1em">ğŸ˜ğŸ‘ŒğŸ”¥</p-fragment>
  <p-fragment no-autoplay style="margin-top: 1em; font-style: italic">...but you can use only on client component...</p-fragment>
</p-slide>
<p-slide>
  <p-note>
    <h5 style="margin-bottom: 0.2em">useSelectedLayoutSegment</h5>
    <p style="margin-bottom: 0.7em" class="small-text">allows retrieval of the active route segment</p>
  </p-note>
  <pre class="small-line" data-label-file="client-component.tsx"><code class="small-text language-javascript">
  'use client'
  import { useSelectedLayoutSegment } from 'next/navigation'
    
  export default function ExampleClientComponent() {
    //Example: if we are on &lt;root>/dashboard/user
    //the retrieved value is the string 'user'."
    const segment = useSelectedLayoutSegment()
    return &lt;p>Active segment: {segment}&lt;/p>
  }

</code></pre>
</p-slide>
<p-slide>
  <p-note>
    <h5 style="margin-bottom: 0.2em">useSelectedLayoutSegments</h5>
    <p style="margin-bottom: 0.7em" class="small-text">allows retrieval of the active route segment and all those before it in an array of values</p>
  </p-note>
  <pre class="small-line" data-label-file="client-component.tsx"><code class="small-text language-javascript">    'use client'
    import { useSelectedLayoutSegments } from 'next/navigation'
      
    export default function ExampleClientComponent() {
      const segments = useSelectedLayoutSegments()
      //Example: if we are on &lt;root>/dashboard/user, 
      //the retrieved value is the array ['dashboard', 'user']."
      return (
        &lt;ul>
          {segments.map((segment, index) => (
            &lt;li key={index}>{segment}&lt;/li>
          ))}
          &lt;/ul>
      )
    }
  </code></pre>
</p-slide>
<p-slide class="center">
  <p-note style="margin-bottom: 1em">
    <h5>â—ï¸All values are relative to where the hook is invoked.â—ï¸</h5>
  </p-note>
  <img src="img/routing.png" alt="routing" class="alter-image-size" />
</p-slide>
<p-slide class="cover-subSection">
  <h1>page.tsx</h1>
</p-slide>
<p-slide>
  <h5 style="margin-bottom: 0.7em">ğŸšª The page file is the entry point for each route</h5>
  <pre data-label-file="page.tsx"><code class="language-javascript">
  // `app/page.tsx` is the UI for the `/` URL
  export default function Page() {
    return &lt;h1>Hello, Home page!&lt;/h1>
  }

</code></pre>
  <p-notes>
    The page file is the entry point for each route.<br />
    Without it, it's not possible to render the requested route. Each page inherits the layouts and templates of that specific route.
  </p-notes>
</p-slide>
<p-slide class="center">
  <p-note>Every page is a server component by default</p-note>
  <p-fragment style="margin-top: 1em">To become a client component you must add <span class="graphik-medium">'use client'</span> at the beginning of the file.</p-fragment>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="page.tsx"><code class="language-javascript">
    'use client'

    // `app/page.tsx` is the UI for the `/` URL
    export default function Page() {
      return &lt;h1>Hello, from the client pageeeee!&lt;/h1>
    }
  </code></pre>
</p-slide>
<p-slide class="cover-subSection">
  <h1>loading.tsx</h1>
</p-slide>
<p-slide class="center">
  <p-note style="margin-bottom: 0.5em">The loading.tsx file is loaded by the framework when UI components are loaded and is nested within the layout. </p-note>
  <p-note>â³</p-note>
</p-slide>
<p-slide>
  <p-note class="mid-dimension"> It encapsulates the <span class="graphik-medium">page.tsx</span> file and its respective children with the native React Suspense tag. </p-note>
  <img class="alter-image-size" src="img/loading-overview.avif" alt="loading-overview" />
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="loading.tsx"><code class="language-javascript">
    export default function Loading() {
      // You can add any UI inside Loading
      return 'Loading...'
    }
  </code></pre>
</p-slide>
<p-slide class="cover-subSection">
  <h1>not-found.tsx</h1>
</p-slide>
<p-slide class="center">
  <p-note>The not-found file serves to provide a courtesy page if a resource not present in the routing of our application is requested</p-note>
  <p-note>ğŸ¤·â€â™‚ï¸</p-note>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="not-found.tsx"><code class="language-javascript">
    import Link from 'next/link'
 
    export default function NotFound() {
      return (
        &lt;div>
          &lt;h2>Not Found&lt;/h2>
          &lt;p>Could not find requested resource&lt;/p>
          &lt;Link href="/">Return Home&lt;/Link>
        &lt/div>
      )
    }</code></pre>
</p-slide>
<p-slide class="center">
  <p-note style="margin-bottom: 1em" class="attention"> Important </p-note>
  <p-note>The not-found file does not accept any type of props</p-note>
</p-slide>
<p-slide class="center">
  <p-note>ğŸ«µ Good to know ğŸ«µ</p-note>
  <p-fragment class="mid-dimension">
    In addition to catching expected notFound() errors, the root app/not-found.tsx file also handles any unmatched URLs for your whole application.</p-fragment
  >
</p-slide>
<p-slide class="cover-subSection">
  <h1>error.tsx / global-error.tsx</h1>
</p-slide>
<p-slide class="center">
  <p-note class="mid-dimension">The error file allows rendering a courtesy page to handle any type of error that may occur during the rendering of a component.</p-note>
  <p-note>ğŸš¨</p-note>
</p-slide>
<p-slide>
  <p-note class="mid-dimension">The framework uses React ErrorBoundary to catch the error, encapsulating the page file inside it.</p-note>
  <img class="alter-image-size" src="img/error-overview.avif" alt="loading-overview" />
</p-slide>
<p-slide class="center">
  <p-note class="mid-dimension"> Through the reset prop, it's possible to request the framework to attempt to reload the component, triggering a new render of it.</p-note>
  <p-fragment class="mid-dimension">
    It's important to remember that a component's error bubbles up through all parent routes until it finds an error component that intercepts them."
  </p-fragment>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="error.tsx"><code class="mid-dimension language-javascript">    'use client' //<- Error components must be Client Components
    export default function Error({ error, reset}: {
      error: Error & { digest?: string }
      reset: () => void
    }) {
      return (
        &lt;div>
          &lt;h2>Something went wrong!&lt;/h2>
          &lt;button onClick={() => reset()}>Try again&lt;/button>
        &lt;/div>
      )
    }</code></pre>
  <p-fragment
    style="--circle-sketch-height: 1.2em;position: absolute;in;inset-inline-start: 7.4em;z-index: 1;inset-block-end: 4.4em;width: 4em;"
    class="circle-sketch-highlight"></p-fragment>
</p-slide>
<p-slide class="cover-subSection">
  <h1>route.tsx</h1>
</p-slide>
<p-slide class="center">
  <p-note class="mid-dimension">Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.</p-note>
  <p-note>ğŸš€</p-note></p-slide
>
<p-slide>
  <h5 style="margin-bottom: 0.7em">Supported HTTP Methods</h5>
  <p-note class="mid-dimension">The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS.</p-note>
  <p-fragment class="center attention" style="margin-bottom: 0.5em">Important</p-fragment>
  <p-fragment class="mid-dimension">If an unsupported method is called, NextJS will return a 405 Method Not Allowed response.</p-fragment>
</p-slide>
<p-slide class="center two-columns-divided-vertically" style="gap: 1em">
  <p-fragment class="small-text">ğŸ‘‡ In this example, a route with the path &lt;root>/api will be generated</p-fragment>
  <img src="img/route-special-file.avif" style="--image-width-size: 20em; --image-start-size: auto" alt="route-special-file" class="alter-image-size" />
  <p-note class="small-text">By convention, they are placed inside the api folder and can be positioned within any segment of the routing</p-note>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="route.tsx"><code class="language-javascript">
    export async function GET() {
      const res = await fetch('https://data.mongodb-api.com/...', {
        headers: {
          'Content-Type': 'application/json',
          'API-Key': process.env.DATA_API_KEY,
        },
      })
      const data = await res.json()
     
      return Response.json({ data })
    }</code></pre>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.7em">ğŸŒŸ Some tips ğŸŒŸ</h4>
  <ul class="mid-dimension">
    <p-fragment><li>ğŸ“Œ Route Handlers are cached by default when using the GET method with the Response object.</li></p-fragment>
    <p-fragment><li>ğŸ“Œ Route do not participate in layouts or client-side navigations like page</li></p-fragment>
    <p-fragment><li>ğŸ“Œ Route cannot be a route.tsx file at the same route as page.tsx.</li></p-fragment>
  </ul>
</p-slide>
<p-slide class="cover-subSection">
  <h1>template.tsx</h1>
</p-slide>
<p-slide class="center">
  <p-note> A template is similar to a layout.</p-note>
  <p-fragment>
    <p style="margin-top: 1em">Unlike layouts that persist across routes and maintain state, templates create a new instance for each of their children on navigation.</p>
    <p>ğŸ–¼ï¸</p>
  </p-fragment>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="template.tsx"><code class="language-javascript">
    export default function Template({ children } {
      return &lt;div>{children}&lt;/div>
    }
  </code></pre>
</p-slide>
<p-slide class="center">
  <h4>Why should I choose templates instead of layouts? ğŸ¤”</h4>
</p-slide>
<p-slide>
  <ul class="mid-dimension">
    <li>ğŸ“Œ Features that rely on useEffect (e.g logging page views) and useState (e.g a per-page feedback form).</li>
    <p-fragment><li>ğŸ“Œ Components that need to be re-rendered on navigation.</li></p-fragment>
    <p-fragment
      ><li>
        ğŸ“Œ To change the default framework behavior. <br />
        For example, Suspense Boundaries inside layouts only show the fallback the first time the Layout is loaded and not when switching pages. For templates, the fallback is
        shown on each navigation.
      </li></p-fragment
    >
  </ul>
</p-slide>
<p-slide class="cover-subSection">
  <h1>default.tsx</h1>
</p-slide>
<p-slide class="center more-space">
  The default file is used to render a fallback within Parallel Routes when NextJS cannot recover a slot's active state after a full-page load.
</p-slide>
<p-slide class="center more-space"> But wait... what is Parallel Route? ğŸ¤” </p-slide>
<p-slide class="center more-space">
  Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout.
  <p class="center" style="margin-top: 0.5em; font-size: 2em">ğŸš´ ğŸš´</p>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">âš™ï¸ How to activate âš™ï¸</h4>
  <img style="--image-start-size: 10em" src="img/parallel-routes.avif" alt="parallel-routes" class="alter-image-size" />
  <p-notes> For example, considering a dashboard, you can use parallel routes to simultaneously render the team and analytics pages </p-notes>
  <p-notes
    >Parallel routes are created using named slots. Slots are defined with the @folder convention. For example, the following file structure defines two slots: @analytics and
    @team</p-notes
  >
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="layout.tsx"><code class="language-javascript">
    export default function Layout({ children, team, analytics}) {
      return (
        &lt;>
          {children}</code>
          <p-fragment><code style="padding: 0; font-weight: bold;" class="language-javascript">{team}</code></p-fragment>
          <p-fragment><code style="padding: 0; font-weight: bold;" class="language-javascript">{analytics}</code></p-fragment><code class="language-javascript">
        &lt;/>
      )
    }
  </code></pre>
</p-slide>
<p-slide class="center"> So this sounds great, but what about the default.tsx file? ğŸ¤” </p-slide>
<p-slide class="center">
  <p-note class="mid-dimension"
    >As we said, the default.tsx file is used to render a fallback within Parallel Routes when NextJS cannot recover a slot's active state after a full-page load.</p-note
  >
  <p-note>ğŸ¤·â€â™‚ï¸</p-note>
  <p-notes>
    This file is optional and can be used to render a fallback UI when the active state of a slot cannot be recovered after a full-page load. It is also used to render a fallback
    UI when the slot is not defined in the layout.
  </p-notes>
  <p-notes> full page load: when user reload the page </p-notes>
</p-slide>
<p-slide>
  <h4 style="margin-bottom: 0.5em" class="center">Some code ğŸ‘¨â€ğŸ’»</h4>
  <pre data-label-file="default.tsx"><code class="language-javascript">
    import Page, { PageProps } from './page'

    export default async function Default(props: PageProps) {
      return (
        &lt;Page {...props} />
      )
    }
  </code></pre>
</p-slide>
